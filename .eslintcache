[{"/Users/ishansengupta/Desktop/three begin/full-distortion/src/index.js":"1","/Users/ishansengupta/Desktop/three begin/full-distortion/src/App.js":"2","/Users/ishansengupta/Desktop/three begin/full-distortion/src/reportWebVitals.js":"3","/Users/ishansengupta/Desktop/three begin/full-distortion/src/Scene.js":"4","/Users/ishansengupta/Desktop/three begin/full-distortion/src/shaders/Fragment.js":"5","/Users/ishansengupta/Desktop/three begin/full-distortion/src/shaders/Vertex.js":"6"},{"size":500,"mtime":1608482111303,"results":"7","hashOfConfig":"8"},{"size":643,"mtime":1608678746986,"results":"9","hashOfConfig":"8"},{"size":362,"mtime":1608482111311,"results":"10","hashOfConfig":"8"},{"size":6589,"mtime":1608678498403,"results":"11","hashOfConfig":"8"},{"size":553,"mtime":1608600823012,"results":"12","hashOfConfig":"8"},{"size":1020,"mtime":1608602827745,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1d73iqa",{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/ishansengupta/Desktop/three begin/full-distortion/src/index.js",[],["29","30"],"/Users/ishansengupta/Desktop/three begin/full-distortion/src/App.js",["31"],"/Users/ishansengupta/Desktop/three begin/full-distortion/src/reportWebVitals.js",[],"/Users/ishansengupta/Desktop/three begin/full-distortion/src/Scene.js",["32"],"import React, { Component } from \"react\";\nimport * as THREE from \"three\";\nimport { vertex } from \"./shaders/Vertex\";\nimport { fragment } from \"./shaders/Fragment\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js';\nclass Scene extends Component {\n  constructor(props) {\n    super(props);\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.animate = this.animate.bind(this);\n  }\n\n  componentDidMount() {\n    this.scene = new THREE.Scene();\n    this.renderer = new THREE.WebGLRenderer({ antialias: true });\n\n    this.renderer.setClearColor(0x000000, 1);\n    this.renderer.setSize(this.width, this.height);\n    this.renderer.physicallyCorrectLights = true;\n    this.renderer.outputEncoding = THREE.sRGBEncoding;\n\n    this.container = document.getElementById(\"scene\");\n    this.width = this.mount.clientWidth;\n    this.height = this.mount.clientHeight;\n    this.mount.appendChild(this.renderer.domElement);\n\n    this.camera = new THREE.PerspectiveCamera(\n      75,\n      this.width / this.height,\n      0.1,\n      1000\n    );\n\n    this.camera.position.set(0, 0, 6);\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.composer = new EffectComposer( this.renderer );\n    this.time = 0;\n    this.setupResize();\n    this.addObjects();\n    this.animate();\n    this.resize();\n  }\n\n  addObjects() {\n    let that = this;\n    this.material = new THREE.ShaderMaterial({\n      extensions: {\n        derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n      },\n      side: THREE.DoubleSide,\n      uniforms: {\n        time: { type: \"f\", value: 0 },\n        resolution: { type: \"v4\", value: new THREE.Vector4() },\n        uvRate1: {\n          value: new THREE.Vector2(1, 1),\n        },\n      },\n      vertexShader: vertex,\n      fragmentShader: fragment,\n    });\n\n    this.renderPass = new RenderPass( this.scene, this.camera );\nthis.composer.addPass( this.renderPass );\n\nthis.glitchPass = new GlitchPass();\nthis.composer.addPass( this.glitchPass );\n\n    \n\n    this.geometry = new THREE.ParametricBufferGeometry(\n      this.torFunction,\n      100,\n      100\n    );\n    this.geometry1 = new THREE.ParametricBufferGeometry(\n      this.graykleinFunction,\n      100,\n      100\n    );\n\n    this.geometry.setAttribute('position1', new THREE.BufferAttribute(this.geometry1.attributes.position.array, 3));\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n  }\n\n  sphereFunction(u, v, target) {\n    u *= Math.PI;\n    v *= -Math.PI * 2;\n\n    let x = Math.sin(u) * Math.sin(v);\n    let y = Math.sin(u) * Math.cos(v);\n    let z = Math.cos(u);\n\n    target.set(x, y, z);\n  }\n\n  torFunction(u, v, target) {\n    u *= Math.PI*2;\n    v *= Math.PI * 2;\n    v -=- Math.PI;\n\n    let x = Math.cos(v) + Math.sin(u)*Math.cos(v);\n    let y = Math.sin(v) + Math.sin(u)*Math.sin(v);\n    let z = Math.cos(u);\n\n    target.set(x, y, z);\n  }\n\n  kleinFunction(u, v, target) {\n    let a = 1;\n    u *= Math.PI * 2 - Math.PI;\n    v *= Math.PI * 2;\n\n    let x =\n      Math.cos(u) *\n      (a +\n        Math.sin(v) * Math.cos(u / 2) -\n        (Math.sin(2 * v) * Math.sin(u / 2)) / 2);\n    let y =\n      Math.sin(u) *\n      (a +\n        Math.sin(v) * Math.cos(u / 2) -\n        (Math.sin(2 * v) * Math.sin(u / 2)) / 2);\n    let z =\n      Math.sin(u / 2) * Math.sin(v) + (Math.cos(u / 2) * Math.sin(2 * v)) / 2;\n\n    target.set(x, y, z);\n  }\n\n  graykleinFunction(u, v, target) {\n    let a = 3;\n    let n = 2;\n    let m = 1;\n    u *= Math.PI * 4;\n    v *= Math.PI * 2;\n\n    let x = (a + Math.cos(n*u / 2.0) * Math.sin(v) - Math.sin(n*u/2.0) * Math.sin(2*v))*Math.cos(m*u/2.0); \n    let y = (a + Math.cos(n*u / 2.0) * Math.sin(v) - Math.sin(n*u/2.0) * Math.sin(2*v))*Math.sin(m*u/2.0);\n    let z = Math.sin(n*u/2.0) * Math.sin(v) + Math.cos(n*u/2.0) * Math.sin(2*v)\n\n    target.set(x, y, z);\n  }\n\n  planeFunction(u, v, target) {\n    let x = u;\n    let y = v;\n    let z = 0;\n\n    target.set(x, y, z);\n  }\n\n  componentWillUnmount() {\n    this.stop();\n    this.mount.removeChild(this.renderer.domElement);\n  }\n\n  setupResize = () => {\n    window.addEventListener(\"resize\", this.resize);\n  };\n\n  resize = () => {\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.renderer.setSize(this.width, this.height);\n    this.camera.aspect = this.width / this.height;\n    console.log(\"resize\");\n\n    /*  this.imageAspect = 853 / 1280;\n\n    let a1;\n    let a2;\n\n    if (this.height / this.width > this.imageAspect) {\n      a1 = (this.width / this.height) * this.imageAspect;\n      a2 = 1;\n    } else {\n      a1 = 1;\n      a2 = this.height / this.width / this.imageAspect;\n    }\n\n    this.material.uniforms.resolution.value.x = this.width;\n    this.material.uniforms.resolution.value.y = this.height;\n    this.material.uniforms.resolution.value.z = a1;\n    this.material.uniforms.resolution.value.w = a2;\n\n    const dist = this.camera.position.z;\n    const height = 1;\n    this.camera.fov = 2* (180/Math.PI) * Math.atan(height/(2*dist));\n\n    if (this.width / this.height > 1) {\n      this.plane.scale.x = this.camera.aspect;\n    } else {\n      this.plane.scale.y = 1 / this.camera.aspect;\n    } */\n\n    this.camera.updateProjectionMatrix();\n    console.log(this.camera);\n  };\n\n  start() {\n    if (!this.frameId) {\n      this.frameId = requestAnimationFrame(this.animate);\n    }\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frameId);\n  }\n\n  animate() {\n    //this.cube.rotation.x += 0.01;\n    //this.cube.rotation.y += 0.01;\n    this.time += 0.05;\n    this.material.uniforms.time.value = this.time;\n\n    /*   this.geometry.vertices.forEach((vector) => {\n      let u = (vector.x + 0.5) * Math.PI * 2;\n      let v = (vector.y + 0.5) * Math.PI;\n\n      vector.x = Math.sin(u) * Math.sin(v);\n      vector.y = Math.sin(u) * Math.cos(v);\n      vector.z = Math.cos(u);\n\n      //v.z = 0.5*Math.sin(v.y * 50.);\n    }); */\n\n    //this.geometry.vertices.needsUpdate = true;\n\n    this.frameId = requestAnimationFrame(this.animate);\n    this.composer.render();\n    this.renderScene();\n  }\n\n  renderScene() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  render() {\n    return (\n      <div\n        id=\"scene\"\n        ref={(mount) => {\n          this.mount = mount;\n        }}\n      />\n    );\n  }\n}\n\nexport default Scene;\n","/Users/ishansengupta/Desktop/three begin/full-distortion/src/shaders/Fragment.js",[],["33","34"],"/Users/ishansengupta/Desktop/three begin/full-distortion/src/shaders/Vertex.js",[],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","severity":1,"message":"40","line":18,"column":7,"nodeType":"41","endLine":18,"endColumn":43},{"ruleId":"42","severity":1,"message":"43","line":50,"column":9,"nodeType":"44","messageId":"45","endLine":50,"endColumn":13},{"ruleId":"35","replacedBy":"46"},{"ruleId":"37","replacedBy":"47"},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-unused-vars","'that' is assigned a value but never used.","Identifier","unusedVar",["48"],["49"],"no-global-assign","no-unsafe-negation"]